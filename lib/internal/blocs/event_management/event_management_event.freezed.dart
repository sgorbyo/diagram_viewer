// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'event_management_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$EventManagementEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startPointerEvent,
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updatePointerEvent,
    required TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endPointerEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startGestureEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updateGestureEvent,
    required TResult Function(
            Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endGestureEvent,
    required TResult Function(KeyEvent rawEvent) startKeyboardEvent,
    required TResult Function(Set<LogicalKeyboardKey> keys) updateModifierKeys,
    required TResult Function() resetState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult? Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult? Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult? Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult? Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult? Function()? resetState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult Function()? resetState,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartPointerEvent value) startPointerEvent,
    required TResult Function(UpdatePointerEvent value) updatePointerEvent,
    required TResult Function(EndPointerEvent value) endPointerEvent,
    required TResult Function(StartGestureEvent value) startGestureEvent,
    required TResult Function(UpdateGestureEvent value) updateGestureEvent,
    required TResult Function(EndGestureEvent value) endGestureEvent,
    required TResult Function(StartKeyboardEvent value) startKeyboardEvent,
    required TResult Function(UpdateModifierKeys value) updateModifierKeys,
    required TResult Function(ResetState value) resetState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartPointerEvent value)? startPointerEvent,
    TResult? Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult? Function(EndPointerEvent value)? endPointerEvent,
    TResult? Function(StartGestureEvent value)? startGestureEvent,
    TResult? Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult? Function(EndGestureEvent value)? endGestureEvent,
    TResult? Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult? Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult? Function(ResetState value)? resetState,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartPointerEvent value)? startPointerEvent,
    TResult Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult Function(EndPointerEvent value)? endPointerEvent,
    TResult Function(StartGestureEvent value)? startGestureEvent,
    TResult Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult Function(EndGestureEvent value)? endGestureEvent,
    TResult Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult Function(ResetState value)? resetState,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EventManagementEventCopyWith<$Res> {
  factory $EventManagementEventCopyWith(EventManagementEvent value,
          $Res Function(EventManagementEvent) then) =
      _$EventManagementEventCopyWithImpl<$Res, EventManagementEvent>;
}

/// @nodoc
class _$EventManagementEventCopyWithImpl<$Res,
        $Val extends EventManagementEvent>
    implements $EventManagementEventCopyWith<$Res> {
  _$EventManagementEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$StartPointerEventImplCopyWith<$Res> {
  factory _$$StartPointerEventImplCopyWith(_$StartPointerEventImpl value,
          $Res Function(_$StartPointerEventImpl) then) =
      __$$StartPointerEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {PointerEvent rawEvent,
      Offset logicalPosition,
      List<HitTestResult> hitResults,
      Set<LogicalKeyboardKey> pressedKeys});
}

/// @nodoc
class __$$StartPointerEventImplCopyWithImpl<$Res>
    extends _$EventManagementEventCopyWithImpl<$Res, _$StartPointerEventImpl>
    implements _$$StartPointerEventImplCopyWith<$Res> {
  __$$StartPointerEventImplCopyWithImpl(_$StartPointerEventImpl _value,
      $Res Function(_$StartPointerEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rawEvent = null,
    Object? logicalPosition = null,
    Object? hitResults = null,
    Object? pressedKeys = null,
  }) {
    return _then(_$StartPointerEventImpl(
      rawEvent: null == rawEvent
          ? _value.rawEvent
          : rawEvent // ignore: cast_nullable_to_non_nullable
              as PointerEvent,
      logicalPosition: null == logicalPosition
          ? _value.logicalPosition
          : logicalPosition // ignore: cast_nullable_to_non_nullable
              as Offset,
      hitResults: null == hitResults
          ? _value._hitResults
          : hitResults // ignore: cast_nullable_to_non_nullable
              as List<HitTestResult>,
      pressedKeys: null == pressedKeys
          ? _value._pressedKeys
          : pressedKeys // ignore: cast_nullable_to_non_nullable
              as Set<LogicalKeyboardKey>,
    ));
  }
}

/// @nodoc

class _$StartPointerEventImpl implements StartPointerEvent {
  const _$StartPointerEventImpl(
      {required this.rawEvent,
      required this.logicalPosition,
      required final List<HitTestResult> hitResults,
      required final Set<LogicalKeyboardKey> pressedKeys})
      : _hitResults = hitResults,
        _pressedKeys = pressedKeys;

  @override
  final PointerEvent rawEvent;
  @override
  final Offset logicalPosition;
  final List<HitTestResult> _hitResults;
  @override
  List<HitTestResult> get hitResults {
    if (_hitResults is EqualUnmodifiableListView) return _hitResults;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_hitResults);
  }

  final Set<LogicalKeyboardKey> _pressedKeys;
  @override
  Set<LogicalKeyboardKey> get pressedKeys {
    if (_pressedKeys is EqualUnmodifiableSetView) return _pressedKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_pressedKeys);
  }

  @override
  String toString() {
    return 'EventManagementEvent.startPointerEvent(rawEvent: $rawEvent, logicalPosition: $logicalPosition, hitResults: $hitResults, pressedKeys: $pressedKeys)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StartPointerEventImpl &&
            (identical(other.rawEvent, rawEvent) ||
                other.rawEvent == rawEvent) &&
            (identical(other.logicalPosition, logicalPosition) ||
                other.logicalPosition == logicalPosition) &&
            const DeepCollectionEquality()
                .equals(other._hitResults, _hitResults) &&
            const DeepCollectionEquality()
                .equals(other._pressedKeys, _pressedKeys));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      rawEvent,
      logicalPosition,
      const DeepCollectionEquality().hash(_hitResults),
      const DeepCollectionEquality().hash(_pressedKeys));

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StartPointerEventImplCopyWith<_$StartPointerEventImpl> get copyWith =>
      __$$StartPointerEventImplCopyWithImpl<_$StartPointerEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startPointerEvent,
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updatePointerEvent,
    required TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endPointerEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startGestureEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updateGestureEvent,
    required TResult Function(
            Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endGestureEvent,
    required TResult Function(KeyEvent rawEvent) startKeyboardEvent,
    required TResult Function(Set<LogicalKeyboardKey> keys) updateModifierKeys,
    required TResult Function() resetState,
  }) {
    return startPointerEvent(
        rawEvent, logicalPosition, hitResults, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult? Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult? Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult? Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult? Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult? Function()? resetState,
  }) {
    return startPointerEvent?.call(
        rawEvent, logicalPosition, hitResults, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult Function()? resetState,
    required TResult orElse(),
  }) {
    if (startPointerEvent != null) {
      return startPointerEvent(
          rawEvent, logicalPosition, hitResults, pressedKeys);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartPointerEvent value) startPointerEvent,
    required TResult Function(UpdatePointerEvent value) updatePointerEvent,
    required TResult Function(EndPointerEvent value) endPointerEvent,
    required TResult Function(StartGestureEvent value) startGestureEvent,
    required TResult Function(UpdateGestureEvent value) updateGestureEvent,
    required TResult Function(EndGestureEvent value) endGestureEvent,
    required TResult Function(StartKeyboardEvent value) startKeyboardEvent,
    required TResult Function(UpdateModifierKeys value) updateModifierKeys,
    required TResult Function(ResetState value) resetState,
  }) {
    return startPointerEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartPointerEvent value)? startPointerEvent,
    TResult? Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult? Function(EndPointerEvent value)? endPointerEvent,
    TResult? Function(StartGestureEvent value)? startGestureEvent,
    TResult? Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult? Function(EndGestureEvent value)? endGestureEvent,
    TResult? Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult? Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult? Function(ResetState value)? resetState,
  }) {
    return startPointerEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartPointerEvent value)? startPointerEvent,
    TResult Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult Function(EndPointerEvent value)? endPointerEvent,
    TResult Function(StartGestureEvent value)? startGestureEvent,
    TResult Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult Function(EndGestureEvent value)? endGestureEvent,
    TResult Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult Function(ResetState value)? resetState,
    required TResult orElse(),
  }) {
    if (startPointerEvent != null) {
      return startPointerEvent(this);
    }
    return orElse();
  }
}

abstract class StartPointerEvent implements EventManagementEvent {
  const factory StartPointerEvent(
          {required final PointerEvent rawEvent,
          required final Offset logicalPosition,
          required final List<HitTestResult> hitResults,
          required final Set<LogicalKeyboardKey> pressedKeys}) =
      _$StartPointerEventImpl;

  PointerEvent get rawEvent;
  Offset get logicalPosition;
  List<HitTestResult> get hitResults;
  Set<LogicalKeyboardKey> get pressedKeys;

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StartPointerEventImplCopyWith<_$StartPointerEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdatePointerEventImplCopyWith<$Res> {
  factory _$$UpdatePointerEventImplCopyWith(_$UpdatePointerEventImpl value,
          $Res Function(_$UpdatePointerEventImpl) then) =
      __$$UpdatePointerEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {PointerEvent rawEvent,
      Offset logicalPosition,
      List<HitTestResult> hitResults,
      Set<LogicalKeyboardKey> pressedKeys});
}

/// @nodoc
class __$$UpdatePointerEventImplCopyWithImpl<$Res>
    extends _$EventManagementEventCopyWithImpl<$Res, _$UpdatePointerEventImpl>
    implements _$$UpdatePointerEventImplCopyWith<$Res> {
  __$$UpdatePointerEventImplCopyWithImpl(_$UpdatePointerEventImpl _value,
      $Res Function(_$UpdatePointerEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rawEvent = null,
    Object? logicalPosition = null,
    Object? hitResults = null,
    Object? pressedKeys = null,
  }) {
    return _then(_$UpdatePointerEventImpl(
      rawEvent: null == rawEvent
          ? _value.rawEvent
          : rawEvent // ignore: cast_nullable_to_non_nullable
              as PointerEvent,
      logicalPosition: null == logicalPosition
          ? _value.logicalPosition
          : logicalPosition // ignore: cast_nullable_to_non_nullable
              as Offset,
      hitResults: null == hitResults
          ? _value._hitResults
          : hitResults // ignore: cast_nullable_to_non_nullable
              as List<HitTestResult>,
      pressedKeys: null == pressedKeys
          ? _value._pressedKeys
          : pressedKeys // ignore: cast_nullable_to_non_nullable
              as Set<LogicalKeyboardKey>,
    ));
  }
}

/// @nodoc

class _$UpdatePointerEventImpl implements UpdatePointerEvent {
  const _$UpdatePointerEventImpl(
      {required this.rawEvent,
      required this.logicalPosition,
      required final List<HitTestResult> hitResults,
      required final Set<LogicalKeyboardKey> pressedKeys})
      : _hitResults = hitResults,
        _pressedKeys = pressedKeys;

  @override
  final PointerEvent rawEvent;
  @override
  final Offset logicalPosition;
  final List<HitTestResult> _hitResults;
  @override
  List<HitTestResult> get hitResults {
    if (_hitResults is EqualUnmodifiableListView) return _hitResults;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_hitResults);
  }

  final Set<LogicalKeyboardKey> _pressedKeys;
  @override
  Set<LogicalKeyboardKey> get pressedKeys {
    if (_pressedKeys is EqualUnmodifiableSetView) return _pressedKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_pressedKeys);
  }

  @override
  String toString() {
    return 'EventManagementEvent.updatePointerEvent(rawEvent: $rawEvent, logicalPosition: $logicalPosition, hitResults: $hitResults, pressedKeys: $pressedKeys)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdatePointerEventImpl &&
            (identical(other.rawEvent, rawEvent) ||
                other.rawEvent == rawEvent) &&
            (identical(other.logicalPosition, logicalPosition) ||
                other.logicalPosition == logicalPosition) &&
            const DeepCollectionEquality()
                .equals(other._hitResults, _hitResults) &&
            const DeepCollectionEquality()
                .equals(other._pressedKeys, _pressedKeys));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      rawEvent,
      logicalPosition,
      const DeepCollectionEquality().hash(_hitResults),
      const DeepCollectionEquality().hash(_pressedKeys));

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdatePointerEventImplCopyWith<_$UpdatePointerEventImpl> get copyWith =>
      __$$UpdatePointerEventImplCopyWithImpl<_$UpdatePointerEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startPointerEvent,
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updatePointerEvent,
    required TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endPointerEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startGestureEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updateGestureEvent,
    required TResult Function(
            Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endGestureEvent,
    required TResult Function(KeyEvent rawEvent) startKeyboardEvent,
    required TResult Function(Set<LogicalKeyboardKey> keys) updateModifierKeys,
    required TResult Function() resetState,
  }) {
    return updatePointerEvent(
        rawEvent, logicalPosition, hitResults, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult? Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult? Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult? Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult? Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult? Function()? resetState,
  }) {
    return updatePointerEvent?.call(
        rawEvent, logicalPosition, hitResults, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult Function()? resetState,
    required TResult orElse(),
  }) {
    if (updatePointerEvent != null) {
      return updatePointerEvent(
          rawEvent, logicalPosition, hitResults, pressedKeys);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartPointerEvent value) startPointerEvent,
    required TResult Function(UpdatePointerEvent value) updatePointerEvent,
    required TResult Function(EndPointerEvent value) endPointerEvent,
    required TResult Function(StartGestureEvent value) startGestureEvent,
    required TResult Function(UpdateGestureEvent value) updateGestureEvent,
    required TResult Function(EndGestureEvent value) endGestureEvent,
    required TResult Function(StartKeyboardEvent value) startKeyboardEvent,
    required TResult Function(UpdateModifierKeys value) updateModifierKeys,
    required TResult Function(ResetState value) resetState,
  }) {
    return updatePointerEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartPointerEvent value)? startPointerEvent,
    TResult? Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult? Function(EndPointerEvent value)? endPointerEvent,
    TResult? Function(StartGestureEvent value)? startGestureEvent,
    TResult? Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult? Function(EndGestureEvent value)? endGestureEvent,
    TResult? Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult? Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult? Function(ResetState value)? resetState,
  }) {
    return updatePointerEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartPointerEvent value)? startPointerEvent,
    TResult Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult Function(EndPointerEvent value)? endPointerEvent,
    TResult Function(StartGestureEvent value)? startGestureEvent,
    TResult Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult Function(EndGestureEvent value)? endGestureEvent,
    TResult Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult Function(ResetState value)? resetState,
    required TResult orElse(),
  }) {
    if (updatePointerEvent != null) {
      return updatePointerEvent(this);
    }
    return orElse();
  }
}

abstract class UpdatePointerEvent implements EventManagementEvent {
  const factory UpdatePointerEvent(
          {required final PointerEvent rawEvent,
          required final Offset logicalPosition,
          required final List<HitTestResult> hitResults,
          required final Set<LogicalKeyboardKey> pressedKeys}) =
      _$UpdatePointerEventImpl;

  PointerEvent get rawEvent;
  Offset get logicalPosition;
  List<HitTestResult> get hitResults;
  Set<LogicalKeyboardKey> get pressedKeys;

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdatePointerEventImplCopyWith<_$UpdatePointerEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EndPointerEventImplCopyWith<$Res> {
  factory _$$EndPointerEventImplCopyWith(_$EndPointerEventImpl value,
          $Res Function(_$EndPointerEventImpl) then) =
      __$$EndPointerEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys});
}

/// @nodoc
class __$$EndPointerEventImplCopyWithImpl<$Res>
    extends _$EventManagementEventCopyWithImpl<$Res, _$EndPointerEventImpl>
    implements _$$EndPointerEventImplCopyWith<$Res> {
  __$$EndPointerEventImplCopyWithImpl(
      _$EndPointerEventImpl _value, $Res Function(_$EndPointerEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rawEvent = null,
    Object? pressedKeys = null,
  }) {
    return _then(_$EndPointerEventImpl(
      rawEvent: null == rawEvent
          ? _value.rawEvent
          : rawEvent // ignore: cast_nullable_to_non_nullable
              as PointerEvent,
      pressedKeys: null == pressedKeys
          ? _value._pressedKeys
          : pressedKeys // ignore: cast_nullable_to_non_nullable
              as Set<LogicalKeyboardKey>,
    ));
  }
}

/// @nodoc

class _$EndPointerEventImpl implements EndPointerEvent {
  const _$EndPointerEventImpl(
      {required this.rawEvent,
      required final Set<LogicalKeyboardKey> pressedKeys})
      : _pressedKeys = pressedKeys;

  @override
  final PointerEvent rawEvent;
  final Set<LogicalKeyboardKey> _pressedKeys;
  @override
  Set<LogicalKeyboardKey> get pressedKeys {
    if (_pressedKeys is EqualUnmodifiableSetView) return _pressedKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_pressedKeys);
  }

  @override
  String toString() {
    return 'EventManagementEvent.endPointerEvent(rawEvent: $rawEvent, pressedKeys: $pressedKeys)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EndPointerEventImpl &&
            (identical(other.rawEvent, rawEvent) ||
                other.rawEvent == rawEvent) &&
            const DeepCollectionEquality()
                .equals(other._pressedKeys, _pressedKeys));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, rawEvent, const DeepCollectionEquality().hash(_pressedKeys));

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EndPointerEventImplCopyWith<_$EndPointerEventImpl> get copyWith =>
      __$$EndPointerEventImplCopyWithImpl<_$EndPointerEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startPointerEvent,
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updatePointerEvent,
    required TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endPointerEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startGestureEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updateGestureEvent,
    required TResult Function(
            Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endGestureEvent,
    required TResult Function(KeyEvent rawEvent) startKeyboardEvent,
    required TResult Function(Set<LogicalKeyboardKey> keys) updateModifierKeys,
    required TResult Function() resetState,
  }) {
    return endPointerEvent(rawEvent, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult? Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult? Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult? Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult? Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult? Function()? resetState,
  }) {
    return endPointerEvent?.call(rawEvent, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult Function()? resetState,
    required TResult orElse(),
  }) {
    if (endPointerEvent != null) {
      return endPointerEvent(rawEvent, pressedKeys);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartPointerEvent value) startPointerEvent,
    required TResult Function(UpdatePointerEvent value) updatePointerEvent,
    required TResult Function(EndPointerEvent value) endPointerEvent,
    required TResult Function(StartGestureEvent value) startGestureEvent,
    required TResult Function(UpdateGestureEvent value) updateGestureEvent,
    required TResult Function(EndGestureEvent value) endGestureEvent,
    required TResult Function(StartKeyboardEvent value) startKeyboardEvent,
    required TResult Function(UpdateModifierKeys value) updateModifierKeys,
    required TResult Function(ResetState value) resetState,
  }) {
    return endPointerEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartPointerEvent value)? startPointerEvent,
    TResult? Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult? Function(EndPointerEvent value)? endPointerEvent,
    TResult? Function(StartGestureEvent value)? startGestureEvent,
    TResult? Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult? Function(EndGestureEvent value)? endGestureEvent,
    TResult? Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult? Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult? Function(ResetState value)? resetState,
  }) {
    return endPointerEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartPointerEvent value)? startPointerEvent,
    TResult Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult Function(EndPointerEvent value)? endPointerEvent,
    TResult Function(StartGestureEvent value)? startGestureEvent,
    TResult Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult Function(EndGestureEvent value)? endGestureEvent,
    TResult Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult Function(ResetState value)? resetState,
    required TResult orElse(),
  }) {
    if (endPointerEvent != null) {
      return endPointerEvent(this);
    }
    return orElse();
  }
}

abstract class EndPointerEvent implements EventManagementEvent {
  const factory EndPointerEvent(
          {required final PointerEvent rawEvent,
          required final Set<LogicalKeyboardKey> pressedKeys}) =
      _$EndPointerEventImpl;

  PointerEvent get rawEvent;
  Set<LogicalKeyboardKey> get pressedKeys;

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EndPointerEventImplCopyWith<_$EndPointerEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StartGestureEventImplCopyWith<$Res> {
  factory _$$StartGestureEventImplCopyWith(_$StartGestureEventImpl value,
          $Res Function(_$StartGestureEventImpl) then) =
      __$$StartGestureEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {Object rawEvent,
      Offset logicalPosition,
      List<HitTestResult> hitResults,
      Set<LogicalKeyboardKey> pressedKeys});
}

/// @nodoc
class __$$StartGestureEventImplCopyWithImpl<$Res>
    extends _$EventManagementEventCopyWithImpl<$Res, _$StartGestureEventImpl>
    implements _$$StartGestureEventImplCopyWith<$Res> {
  __$$StartGestureEventImplCopyWithImpl(_$StartGestureEventImpl _value,
      $Res Function(_$StartGestureEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rawEvent = null,
    Object? logicalPosition = null,
    Object? hitResults = null,
    Object? pressedKeys = null,
  }) {
    return _then(_$StartGestureEventImpl(
      rawEvent: null == rawEvent ? _value.rawEvent : rawEvent,
      logicalPosition: null == logicalPosition
          ? _value.logicalPosition
          : logicalPosition // ignore: cast_nullable_to_non_nullable
              as Offset,
      hitResults: null == hitResults
          ? _value._hitResults
          : hitResults // ignore: cast_nullable_to_non_nullable
              as List<HitTestResult>,
      pressedKeys: null == pressedKeys
          ? _value._pressedKeys
          : pressedKeys // ignore: cast_nullable_to_non_nullable
              as Set<LogicalKeyboardKey>,
    ));
  }
}

/// @nodoc

class _$StartGestureEventImpl implements StartGestureEvent {
  const _$StartGestureEventImpl(
      {required this.rawEvent,
      required this.logicalPosition,
      required final List<HitTestResult> hitResults,
      required final Set<LogicalKeyboardKey> pressedKeys})
      : _hitResults = hitResults,
        _pressedKeys = pressedKeys;

  @override
  final Object rawEvent;
  @override
  final Offset logicalPosition;
  final List<HitTestResult> _hitResults;
  @override
  List<HitTestResult> get hitResults {
    if (_hitResults is EqualUnmodifiableListView) return _hitResults;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_hitResults);
  }

  final Set<LogicalKeyboardKey> _pressedKeys;
  @override
  Set<LogicalKeyboardKey> get pressedKeys {
    if (_pressedKeys is EqualUnmodifiableSetView) return _pressedKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_pressedKeys);
  }

  @override
  String toString() {
    return 'EventManagementEvent.startGestureEvent(rawEvent: $rawEvent, logicalPosition: $logicalPosition, hitResults: $hitResults, pressedKeys: $pressedKeys)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StartGestureEventImpl &&
            const DeepCollectionEquality().equals(other.rawEvent, rawEvent) &&
            (identical(other.logicalPosition, logicalPosition) ||
                other.logicalPosition == logicalPosition) &&
            const DeepCollectionEquality()
                .equals(other._hitResults, _hitResults) &&
            const DeepCollectionEquality()
                .equals(other._pressedKeys, _pressedKeys));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(rawEvent),
      logicalPosition,
      const DeepCollectionEquality().hash(_hitResults),
      const DeepCollectionEquality().hash(_pressedKeys));

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StartGestureEventImplCopyWith<_$StartGestureEventImpl> get copyWith =>
      __$$StartGestureEventImplCopyWithImpl<_$StartGestureEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startPointerEvent,
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updatePointerEvent,
    required TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endPointerEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startGestureEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updateGestureEvent,
    required TResult Function(
            Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endGestureEvent,
    required TResult Function(KeyEvent rawEvent) startKeyboardEvent,
    required TResult Function(Set<LogicalKeyboardKey> keys) updateModifierKeys,
    required TResult Function() resetState,
  }) {
    return startGestureEvent(
        rawEvent, logicalPosition, hitResults, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult? Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult? Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult? Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult? Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult? Function()? resetState,
  }) {
    return startGestureEvent?.call(
        rawEvent, logicalPosition, hitResults, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult Function()? resetState,
    required TResult orElse(),
  }) {
    if (startGestureEvent != null) {
      return startGestureEvent(
          rawEvent, logicalPosition, hitResults, pressedKeys);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartPointerEvent value) startPointerEvent,
    required TResult Function(UpdatePointerEvent value) updatePointerEvent,
    required TResult Function(EndPointerEvent value) endPointerEvent,
    required TResult Function(StartGestureEvent value) startGestureEvent,
    required TResult Function(UpdateGestureEvent value) updateGestureEvent,
    required TResult Function(EndGestureEvent value) endGestureEvent,
    required TResult Function(StartKeyboardEvent value) startKeyboardEvent,
    required TResult Function(UpdateModifierKeys value) updateModifierKeys,
    required TResult Function(ResetState value) resetState,
  }) {
    return startGestureEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartPointerEvent value)? startPointerEvent,
    TResult? Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult? Function(EndPointerEvent value)? endPointerEvent,
    TResult? Function(StartGestureEvent value)? startGestureEvent,
    TResult? Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult? Function(EndGestureEvent value)? endGestureEvent,
    TResult? Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult? Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult? Function(ResetState value)? resetState,
  }) {
    return startGestureEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartPointerEvent value)? startPointerEvent,
    TResult Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult Function(EndPointerEvent value)? endPointerEvent,
    TResult Function(StartGestureEvent value)? startGestureEvent,
    TResult Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult Function(EndGestureEvent value)? endGestureEvent,
    TResult Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult Function(ResetState value)? resetState,
    required TResult orElse(),
  }) {
    if (startGestureEvent != null) {
      return startGestureEvent(this);
    }
    return orElse();
  }
}

abstract class StartGestureEvent implements EventManagementEvent {
  const factory StartGestureEvent(
          {required final Object rawEvent,
          required final Offset logicalPosition,
          required final List<HitTestResult> hitResults,
          required final Set<LogicalKeyboardKey> pressedKeys}) =
      _$StartGestureEventImpl;

  Object get rawEvent;
  Offset get logicalPosition;
  List<HitTestResult> get hitResults;
  Set<LogicalKeyboardKey> get pressedKeys;

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StartGestureEventImplCopyWith<_$StartGestureEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateGestureEventImplCopyWith<$Res> {
  factory _$$UpdateGestureEventImplCopyWith(_$UpdateGestureEventImpl value,
          $Res Function(_$UpdateGestureEventImpl) then) =
      __$$UpdateGestureEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {Object rawEvent,
      Offset logicalPosition,
      List<HitTestResult> hitResults,
      Set<LogicalKeyboardKey> pressedKeys});
}

/// @nodoc
class __$$UpdateGestureEventImplCopyWithImpl<$Res>
    extends _$EventManagementEventCopyWithImpl<$Res, _$UpdateGestureEventImpl>
    implements _$$UpdateGestureEventImplCopyWith<$Res> {
  __$$UpdateGestureEventImplCopyWithImpl(_$UpdateGestureEventImpl _value,
      $Res Function(_$UpdateGestureEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rawEvent = null,
    Object? logicalPosition = null,
    Object? hitResults = null,
    Object? pressedKeys = null,
  }) {
    return _then(_$UpdateGestureEventImpl(
      rawEvent: null == rawEvent ? _value.rawEvent : rawEvent,
      logicalPosition: null == logicalPosition
          ? _value.logicalPosition
          : logicalPosition // ignore: cast_nullable_to_non_nullable
              as Offset,
      hitResults: null == hitResults
          ? _value._hitResults
          : hitResults // ignore: cast_nullable_to_non_nullable
              as List<HitTestResult>,
      pressedKeys: null == pressedKeys
          ? _value._pressedKeys
          : pressedKeys // ignore: cast_nullable_to_non_nullable
              as Set<LogicalKeyboardKey>,
    ));
  }
}

/// @nodoc

class _$UpdateGestureEventImpl implements UpdateGestureEvent {
  const _$UpdateGestureEventImpl(
      {required this.rawEvent,
      required this.logicalPosition,
      required final List<HitTestResult> hitResults,
      required final Set<LogicalKeyboardKey> pressedKeys})
      : _hitResults = hitResults,
        _pressedKeys = pressedKeys;

  @override
  final Object rawEvent;
  @override
  final Offset logicalPosition;
  final List<HitTestResult> _hitResults;
  @override
  List<HitTestResult> get hitResults {
    if (_hitResults is EqualUnmodifiableListView) return _hitResults;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_hitResults);
  }

  final Set<LogicalKeyboardKey> _pressedKeys;
  @override
  Set<LogicalKeyboardKey> get pressedKeys {
    if (_pressedKeys is EqualUnmodifiableSetView) return _pressedKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_pressedKeys);
  }

  @override
  String toString() {
    return 'EventManagementEvent.updateGestureEvent(rawEvent: $rawEvent, logicalPosition: $logicalPosition, hitResults: $hitResults, pressedKeys: $pressedKeys)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateGestureEventImpl &&
            const DeepCollectionEquality().equals(other.rawEvent, rawEvent) &&
            (identical(other.logicalPosition, logicalPosition) ||
                other.logicalPosition == logicalPosition) &&
            const DeepCollectionEquality()
                .equals(other._hitResults, _hitResults) &&
            const DeepCollectionEquality()
                .equals(other._pressedKeys, _pressedKeys));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(rawEvent),
      logicalPosition,
      const DeepCollectionEquality().hash(_hitResults),
      const DeepCollectionEquality().hash(_pressedKeys));

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateGestureEventImplCopyWith<_$UpdateGestureEventImpl> get copyWith =>
      __$$UpdateGestureEventImplCopyWithImpl<_$UpdateGestureEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startPointerEvent,
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updatePointerEvent,
    required TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endPointerEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startGestureEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updateGestureEvent,
    required TResult Function(
            Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endGestureEvent,
    required TResult Function(KeyEvent rawEvent) startKeyboardEvent,
    required TResult Function(Set<LogicalKeyboardKey> keys) updateModifierKeys,
    required TResult Function() resetState,
  }) {
    return updateGestureEvent(
        rawEvent, logicalPosition, hitResults, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult? Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult? Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult? Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult? Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult? Function()? resetState,
  }) {
    return updateGestureEvent?.call(
        rawEvent, logicalPosition, hitResults, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult Function()? resetState,
    required TResult orElse(),
  }) {
    if (updateGestureEvent != null) {
      return updateGestureEvent(
          rawEvent, logicalPosition, hitResults, pressedKeys);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartPointerEvent value) startPointerEvent,
    required TResult Function(UpdatePointerEvent value) updatePointerEvent,
    required TResult Function(EndPointerEvent value) endPointerEvent,
    required TResult Function(StartGestureEvent value) startGestureEvent,
    required TResult Function(UpdateGestureEvent value) updateGestureEvent,
    required TResult Function(EndGestureEvent value) endGestureEvent,
    required TResult Function(StartKeyboardEvent value) startKeyboardEvent,
    required TResult Function(UpdateModifierKeys value) updateModifierKeys,
    required TResult Function(ResetState value) resetState,
  }) {
    return updateGestureEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartPointerEvent value)? startPointerEvent,
    TResult? Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult? Function(EndPointerEvent value)? endPointerEvent,
    TResult? Function(StartGestureEvent value)? startGestureEvent,
    TResult? Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult? Function(EndGestureEvent value)? endGestureEvent,
    TResult? Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult? Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult? Function(ResetState value)? resetState,
  }) {
    return updateGestureEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartPointerEvent value)? startPointerEvent,
    TResult Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult Function(EndPointerEvent value)? endPointerEvent,
    TResult Function(StartGestureEvent value)? startGestureEvent,
    TResult Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult Function(EndGestureEvent value)? endGestureEvent,
    TResult Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult Function(ResetState value)? resetState,
    required TResult orElse(),
  }) {
    if (updateGestureEvent != null) {
      return updateGestureEvent(this);
    }
    return orElse();
  }
}

abstract class UpdateGestureEvent implements EventManagementEvent {
  const factory UpdateGestureEvent(
          {required final Object rawEvent,
          required final Offset logicalPosition,
          required final List<HitTestResult> hitResults,
          required final Set<LogicalKeyboardKey> pressedKeys}) =
      _$UpdateGestureEventImpl;

  Object get rawEvent;
  Offset get logicalPosition;
  List<HitTestResult> get hitResults;
  Set<LogicalKeyboardKey> get pressedKeys;

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateGestureEventImplCopyWith<_$UpdateGestureEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EndGestureEventImplCopyWith<$Res> {
  factory _$$EndGestureEventImplCopyWith(_$EndGestureEventImpl value,
          $Res Function(_$EndGestureEventImpl) then) =
      __$$EndGestureEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Object rawEvent, Set<LogicalKeyboardKey> pressedKeys});
}

/// @nodoc
class __$$EndGestureEventImplCopyWithImpl<$Res>
    extends _$EventManagementEventCopyWithImpl<$Res, _$EndGestureEventImpl>
    implements _$$EndGestureEventImplCopyWith<$Res> {
  __$$EndGestureEventImplCopyWithImpl(
      _$EndGestureEventImpl _value, $Res Function(_$EndGestureEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rawEvent = null,
    Object? pressedKeys = null,
  }) {
    return _then(_$EndGestureEventImpl(
      rawEvent: null == rawEvent ? _value.rawEvent : rawEvent,
      pressedKeys: null == pressedKeys
          ? _value._pressedKeys
          : pressedKeys // ignore: cast_nullable_to_non_nullable
              as Set<LogicalKeyboardKey>,
    ));
  }
}

/// @nodoc

class _$EndGestureEventImpl implements EndGestureEvent {
  const _$EndGestureEventImpl(
      {required this.rawEvent,
      required final Set<LogicalKeyboardKey> pressedKeys})
      : _pressedKeys = pressedKeys;

  @override
  final Object rawEvent;
  final Set<LogicalKeyboardKey> _pressedKeys;
  @override
  Set<LogicalKeyboardKey> get pressedKeys {
    if (_pressedKeys is EqualUnmodifiableSetView) return _pressedKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_pressedKeys);
  }

  @override
  String toString() {
    return 'EventManagementEvent.endGestureEvent(rawEvent: $rawEvent, pressedKeys: $pressedKeys)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EndGestureEventImpl &&
            const DeepCollectionEquality().equals(other.rawEvent, rawEvent) &&
            const DeepCollectionEquality()
                .equals(other._pressedKeys, _pressedKeys));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(rawEvent),
      const DeepCollectionEquality().hash(_pressedKeys));

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EndGestureEventImplCopyWith<_$EndGestureEventImpl> get copyWith =>
      __$$EndGestureEventImplCopyWithImpl<_$EndGestureEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startPointerEvent,
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updatePointerEvent,
    required TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endPointerEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startGestureEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updateGestureEvent,
    required TResult Function(
            Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endGestureEvent,
    required TResult Function(KeyEvent rawEvent) startKeyboardEvent,
    required TResult Function(Set<LogicalKeyboardKey> keys) updateModifierKeys,
    required TResult Function() resetState,
  }) {
    return endGestureEvent(rawEvent, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult? Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult? Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult? Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult? Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult? Function()? resetState,
  }) {
    return endGestureEvent?.call(rawEvent, pressedKeys);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult Function()? resetState,
    required TResult orElse(),
  }) {
    if (endGestureEvent != null) {
      return endGestureEvent(rawEvent, pressedKeys);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartPointerEvent value) startPointerEvent,
    required TResult Function(UpdatePointerEvent value) updatePointerEvent,
    required TResult Function(EndPointerEvent value) endPointerEvent,
    required TResult Function(StartGestureEvent value) startGestureEvent,
    required TResult Function(UpdateGestureEvent value) updateGestureEvent,
    required TResult Function(EndGestureEvent value) endGestureEvent,
    required TResult Function(StartKeyboardEvent value) startKeyboardEvent,
    required TResult Function(UpdateModifierKeys value) updateModifierKeys,
    required TResult Function(ResetState value) resetState,
  }) {
    return endGestureEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartPointerEvent value)? startPointerEvent,
    TResult? Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult? Function(EndPointerEvent value)? endPointerEvent,
    TResult? Function(StartGestureEvent value)? startGestureEvent,
    TResult? Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult? Function(EndGestureEvent value)? endGestureEvent,
    TResult? Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult? Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult? Function(ResetState value)? resetState,
  }) {
    return endGestureEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartPointerEvent value)? startPointerEvent,
    TResult Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult Function(EndPointerEvent value)? endPointerEvent,
    TResult Function(StartGestureEvent value)? startGestureEvent,
    TResult Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult Function(EndGestureEvent value)? endGestureEvent,
    TResult Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult Function(ResetState value)? resetState,
    required TResult orElse(),
  }) {
    if (endGestureEvent != null) {
      return endGestureEvent(this);
    }
    return orElse();
  }
}

abstract class EndGestureEvent implements EventManagementEvent {
  const factory EndGestureEvent(
          {required final Object rawEvent,
          required final Set<LogicalKeyboardKey> pressedKeys}) =
      _$EndGestureEventImpl;

  Object get rawEvent;
  Set<LogicalKeyboardKey> get pressedKeys;

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EndGestureEventImplCopyWith<_$EndGestureEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$StartKeyboardEventImplCopyWith<$Res> {
  factory _$$StartKeyboardEventImplCopyWith(_$StartKeyboardEventImpl value,
          $Res Function(_$StartKeyboardEventImpl) then) =
      __$$StartKeyboardEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({KeyEvent rawEvent});
}

/// @nodoc
class __$$StartKeyboardEventImplCopyWithImpl<$Res>
    extends _$EventManagementEventCopyWithImpl<$Res, _$StartKeyboardEventImpl>
    implements _$$StartKeyboardEventImplCopyWith<$Res> {
  __$$StartKeyboardEventImplCopyWithImpl(_$StartKeyboardEventImpl _value,
      $Res Function(_$StartKeyboardEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? rawEvent = null,
  }) {
    return _then(_$StartKeyboardEventImpl(
      rawEvent: null == rawEvent
          ? _value.rawEvent
          : rawEvent // ignore: cast_nullable_to_non_nullable
              as KeyEvent,
    ));
  }
}

/// @nodoc

class _$StartKeyboardEventImpl implements StartKeyboardEvent {
  const _$StartKeyboardEventImpl({required this.rawEvent});

  @override
  final KeyEvent rawEvent;

  @override
  String toString() {
    return 'EventManagementEvent.startKeyboardEvent(rawEvent: $rawEvent)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$StartKeyboardEventImpl &&
            (identical(other.rawEvent, rawEvent) ||
                other.rawEvent == rawEvent));
  }

  @override
  int get hashCode => Object.hash(runtimeType, rawEvent);

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$StartKeyboardEventImplCopyWith<_$StartKeyboardEventImpl> get copyWith =>
      __$$StartKeyboardEventImplCopyWithImpl<_$StartKeyboardEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startPointerEvent,
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updatePointerEvent,
    required TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endPointerEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startGestureEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updateGestureEvent,
    required TResult Function(
            Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endGestureEvent,
    required TResult Function(KeyEvent rawEvent) startKeyboardEvent,
    required TResult Function(Set<LogicalKeyboardKey> keys) updateModifierKeys,
    required TResult Function() resetState,
  }) {
    return startKeyboardEvent(rawEvent);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult? Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult? Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult? Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult? Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult? Function()? resetState,
  }) {
    return startKeyboardEvent?.call(rawEvent);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult Function()? resetState,
    required TResult orElse(),
  }) {
    if (startKeyboardEvent != null) {
      return startKeyboardEvent(rawEvent);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartPointerEvent value) startPointerEvent,
    required TResult Function(UpdatePointerEvent value) updatePointerEvent,
    required TResult Function(EndPointerEvent value) endPointerEvent,
    required TResult Function(StartGestureEvent value) startGestureEvent,
    required TResult Function(UpdateGestureEvent value) updateGestureEvent,
    required TResult Function(EndGestureEvent value) endGestureEvent,
    required TResult Function(StartKeyboardEvent value) startKeyboardEvent,
    required TResult Function(UpdateModifierKeys value) updateModifierKeys,
    required TResult Function(ResetState value) resetState,
  }) {
    return startKeyboardEvent(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartPointerEvent value)? startPointerEvent,
    TResult? Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult? Function(EndPointerEvent value)? endPointerEvent,
    TResult? Function(StartGestureEvent value)? startGestureEvent,
    TResult? Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult? Function(EndGestureEvent value)? endGestureEvent,
    TResult? Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult? Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult? Function(ResetState value)? resetState,
  }) {
    return startKeyboardEvent?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartPointerEvent value)? startPointerEvent,
    TResult Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult Function(EndPointerEvent value)? endPointerEvent,
    TResult Function(StartGestureEvent value)? startGestureEvent,
    TResult Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult Function(EndGestureEvent value)? endGestureEvent,
    TResult Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult Function(ResetState value)? resetState,
    required TResult orElse(),
  }) {
    if (startKeyboardEvent != null) {
      return startKeyboardEvent(this);
    }
    return orElse();
  }
}

abstract class StartKeyboardEvent implements EventManagementEvent {
  const factory StartKeyboardEvent({required final KeyEvent rawEvent}) =
      _$StartKeyboardEventImpl;

  KeyEvent get rawEvent;

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$StartKeyboardEventImplCopyWith<_$StartKeyboardEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateModifierKeysImplCopyWith<$Res> {
  factory _$$UpdateModifierKeysImplCopyWith(_$UpdateModifierKeysImpl value,
          $Res Function(_$UpdateModifierKeysImpl) then) =
      __$$UpdateModifierKeysImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Set<LogicalKeyboardKey> keys});
}

/// @nodoc
class __$$UpdateModifierKeysImplCopyWithImpl<$Res>
    extends _$EventManagementEventCopyWithImpl<$Res, _$UpdateModifierKeysImpl>
    implements _$$UpdateModifierKeysImplCopyWith<$Res> {
  __$$UpdateModifierKeysImplCopyWithImpl(_$UpdateModifierKeysImpl _value,
      $Res Function(_$UpdateModifierKeysImpl) _then)
      : super(_value, _then);

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? keys = null,
  }) {
    return _then(_$UpdateModifierKeysImpl(
      keys: null == keys
          ? _value._keys
          : keys // ignore: cast_nullable_to_non_nullable
              as Set<LogicalKeyboardKey>,
    ));
  }
}

/// @nodoc

class _$UpdateModifierKeysImpl implements UpdateModifierKeys {
  const _$UpdateModifierKeysImpl({required final Set<LogicalKeyboardKey> keys})
      : _keys = keys;

  final Set<LogicalKeyboardKey> _keys;
  @override
  Set<LogicalKeyboardKey> get keys {
    if (_keys is EqualUnmodifiableSetView) return _keys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_keys);
  }

  @override
  String toString() {
    return 'EventManagementEvent.updateModifierKeys(keys: $keys)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateModifierKeysImpl &&
            const DeepCollectionEquality().equals(other._keys, _keys));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_keys));

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateModifierKeysImplCopyWith<_$UpdateModifierKeysImpl> get copyWith =>
      __$$UpdateModifierKeysImplCopyWithImpl<_$UpdateModifierKeysImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startPointerEvent,
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updatePointerEvent,
    required TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endPointerEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startGestureEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updateGestureEvent,
    required TResult Function(
            Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endGestureEvent,
    required TResult Function(KeyEvent rawEvent) startKeyboardEvent,
    required TResult Function(Set<LogicalKeyboardKey> keys) updateModifierKeys,
    required TResult Function() resetState,
  }) {
    return updateModifierKeys(keys);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult? Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult? Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult? Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult? Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult? Function()? resetState,
  }) {
    return updateModifierKeys?.call(keys);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult Function()? resetState,
    required TResult orElse(),
  }) {
    if (updateModifierKeys != null) {
      return updateModifierKeys(keys);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartPointerEvent value) startPointerEvent,
    required TResult Function(UpdatePointerEvent value) updatePointerEvent,
    required TResult Function(EndPointerEvent value) endPointerEvent,
    required TResult Function(StartGestureEvent value) startGestureEvent,
    required TResult Function(UpdateGestureEvent value) updateGestureEvent,
    required TResult Function(EndGestureEvent value) endGestureEvent,
    required TResult Function(StartKeyboardEvent value) startKeyboardEvent,
    required TResult Function(UpdateModifierKeys value) updateModifierKeys,
    required TResult Function(ResetState value) resetState,
  }) {
    return updateModifierKeys(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartPointerEvent value)? startPointerEvent,
    TResult? Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult? Function(EndPointerEvent value)? endPointerEvent,
    TResult? Function(StartGestureEvent value)? startGestureEvent,
    TResult? Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult? Function(EndGestureEvent value)? endGestureEvent,
    TResult? Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult? Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult? Function(ResetState value)? resetState,
  }) {
    return updateModifierKeys?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartPointerEvent value)? startPointerEvent,
    TResult Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult Function(EndPointerEvent value)? endPointerEvent,
    TResult Function(StartGestureEvent value)? startGestureEvent,
    TResult Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult Function(EndGestureEvent value)? endGestureEvent,
    TResult Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult Function(ResetState value)? resetState,
    required TResult orElse(),
  }) {
    if (updateModifierKeys != null) {
      return updateModifierKeys(this);
    }
    return orElse();
  }
}

abstract class UpdateModifierKeys implements EventManagementEvent {
  const factory UpdateModifierKeys(
      {required final Set<LogicalKeyboardKey> keys}) = _$UpdateModifierKeysImpl;

  Set<LogicalKeyboardKey> get keys;

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateModifierKeysImplCopyWith<_$UpdateModifierKeysImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ResetStateImplCopyWith<$Res> {
  factory _$$ResetStateImplCopyWith(
          _$ResetStateImpl value, $Res Function(_$ResetStateImpl) then) =
      __$$ResetStateImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ResetStateImplCopyWithImpl<$Res>
    extends _$EventManagementEventCopyWithImpl<$Res, _$ResetStateImpl>
    implements _$$ResetStateImplCopyWith<$Res> {
  __$$ResetStateImplCopyWithImpl(
      _$ResetStateImpl _value, $Res Function(_$ResetStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of EventManagementEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ResetStateImpl implements ResetState {
  const _$ResetStateImpl();

  @override
  String toString() {
    return 'EventManagementEvent.resetState()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ResetStateImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startPointerEvent,
    required TResult Function(PointerEvent rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updatePointerEvent,
    required TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endPointerEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        startGestureEvent,
    required TResult Function(Object rawEvent, Offset logicalPosition,
            List<HitTestResult> hitResults, Set<LogicalKeyboardKey> pressedKeys)
        updateGestureEvent,
    required TResult Function(
            Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)
        endGestureEvent,
    required TResult Function(KeyEvent rawEvent) startKeyboardEvent,
    required TResult Function(Set<LogicalKeyboardKey> keys) updateModifierKeys,
    required TResult Function() resetState,
  }) {
    return resetState();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult? Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult? Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult? Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult? Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult? Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult? Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult? Function()? resetState,
  }) {
    return resetState?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startPointerEvent,
    TResult Function(
            PointerEvent rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updatePointerEvent,
    TResult Function(
            PointerEvent rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endPointerEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        startGestureEvent,
    TResult Function(
            Object rawEvent,
            Offset logicalPosition,
            List<HitTestResult> hitResults,
            Set<LogicalKeyboardKey> pressedKeys)?
        updateGestureEvent,
    TResult Function(Object rawEvent, Set<LogicalKeyboardKey> pressedKeys)?
        endGestureEvent,
    TResult Function(KeyEvent rawEvent)? startKeyboardEvent,
    TResult Function(Set<LogicalKeyboardKey> keys)? updateModifierKeys,
    TResult Function()? resetState,
    required TResult orElse(),
  }) {
    if (resetState != null) {
      return resetState();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(StartPointerEvent value) startPointerEvent,
    required TResult Function(UpdatePointerEvent value) updatePointerEvent,
    required TResult Function(EndPointerEvent value) endPointerEvent,
    required TResult Function(StartGestureEvent value) startGestureEvent,
    required TResult Function(UpdateGestureEvent value) updateGestureEvent,
    required TResult Function(EndGestureEvent value) endGestureEvent,
    required TResult Function(StartKeyboardEvent value) startKeyboardEvent,
    required TResult Function(UpdateModifierKeys value) updateModifierKeys,
    required TResult Function(ResetState value) resetState,
  }) {
    return resetState(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(StartPointerEvent value)? startPointerEvent,
    TResult? Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult? Function(EndPointerEvent value)? endPointerEvent,
    TResult? Function(StartGestureEvent value)? startGestureEvent,
    TResult? Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult? Function(EndGestureEvent value)? endGestureEvent,
    TResult? Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult? Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult? Function(ResetState value)? resetState,
  }) {
    return resetState?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(StartPointerEvent value)? startPointerEvent,
    TResult Function(UpdatePointerEvent value)? updatePointerEvent,
    TResult Function(EndPointerEvent value)? endPointerEvent,
    TResult Function(StartGestureEvent value)? startGestureEvent,
    TResult Function(UpdateGestureEvent value)? updateGestureEvent,
    TResult Function(EndGestureEvent value)? endGestureEvent,
    TResult Function(StartKeyboardEvent value)? startKeyboardEvent,
    TResult Function(UpdateModifierKeys value)? updateModifierKeys,
    TResult Function(ResetState value)? resetState,
    required TResult orElse(),
  }) {
    if (resetState != null) {
      return resetState(this);
    }
    return orElse();
  }
}

abstract class ResetState implements EventManagementEvent {
  const factory ResetState() = _$ResetStateImpl;
}
